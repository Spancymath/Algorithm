package com.zhang.Chapter42;

/**
 * 有向图
 */
public class AnswerList {
    /**
     * 1.标记-清除的垃圾收集算法实现类似于有向图的可达性算法
     * 2.使用深度优先搜索对有向无环图进行拓扑排序所需的时间和V+E成正比
     * 3.如果两个顶点v和w是互相可达的，则称他们为强连通
     * 4.强连通分量：
     *     -自反性：任意顶点v和自己都是强连通的
     *     -对称性：如果v和w是强连通的，那么w和v也是强连通的
     *     -传递性：如果v和w是强连通的且w和x也是强连通的，那么v和x也是强连通的
     * 5.DAG: Directed acyclic graph有向无环图
     */
    /**
     * 4.2.1
     * Solution:
     *      最多有n(n-1)
     *      最少需要n-1
     */
    /**
     * 4.2.9 判断序列是拓扑排序序列
     * Solution:
     *      循环：
     *        判断序列的下一个顶点入读是否为0，否则不是拓扑序列
     *        将下一个顶点弹出，将它相邻顶点的入度都减一
     *      详见Degrees
     */
    /**
     * 4.2.11
     * Solution:
     *      加入进来的顶点都与已经存在的顶点相连
     */
    /**
     * 4.2.12
     * Solution:
     *      传递闭包：邻接矩阵，连通的边（包含相邻以及通过其他点相连）值为1，其他值为0
     *          注：自反传递闭包，认为自身和自身本来就是相连的
     *      简单路径：没有重复顶点的路径
     *      所以类似a-->b-->c-...->w
     *      (v-1)v/2条边
     */
    /**
     * 4.2.13 传递闭包
     * Solution:
     *      邻接矩阵                 闭包
     *        0 1 2 3 4 5 6 7 8 9     0 1 2 3 4 5 6 7 8 9
     *      0 0 0 0 0 0 1 1 0 0 0   0 0 0 1 0 1 1 1 0 0 1
     *      1 0 0 0 0 1 0 0 0 0 0   1 0 0 0 0 1 0 0 0 0 1
     *      2 0 0 0 0 0 0 1 0 0 1   2 0 0 0 0 1 0 1 0 0 1
     *      3 0 0 0 0 0 0 0 1 1 0   3 0 0 0 0 0 0 0 1 1 0
     *      4 0 0 0 0 0 0 0 0 0 1   4 0 0 0 0 0 0 0 0 0 1
     *      5 0 0 1 0 0 0 0 0 0 0   5 0 0 1 0 1 0 1 0 0 1
     *      6 0 0 0 0 1 0 0 0 0 0   6 0 0 0 0 1 0 0 0 0 1
     *      7 0 0 0 0 0 0 0 0 1 0   7 0 0 0 0 0 0 0 0 1 0
     *      8 0 0 0 0 0 0 0 0 0 0   8 0 0 0 0 0 0 0 0 0 0
     *      9 0 0 0 0 0 0 0 0 0 0   9 0 0 0 0 0 0 0 0 0 0
     */
    /**
     * 4.2.14 图和反向图的强连通分量相同
     * Solution:
     *      强连通必然存在环，环的所有边都反向还是环，故还是强连通
     */
    /**
     * 4.2.15 有向无环图的强连通分量
     * Solution:
     *      所有顶点自身
     */
    /**
     * 4.2.16 Kosaraju处理有向无环图
     * Solution:
     *      依次输出所有顶点
     */
    /**
     * 4.2.17 反向图的逆后序和该图的后序排列相同
     * Solution:
     *      false, 否则Kosaraju就用后序排列了
     */
    /**
     * 4.2.19
     * Solution:
     *      存在两个起点就无法标记
     *      存在两个顶点中间有两个不等长的路劲就无法标记
     */
    /**
     * 4.2.21 有向无环图的LCA
     * Solution:
     *      根结点到任一顶点的最长路径，由于无环，从根结点广度优先遍历，可以重复遍历，更新高度值
     *      v和w的共同祖先：求出闭包，找出共同的祖先
     *      有最大距离的祖先即为所求
     *      祖先：从顶点深度优先搜索，得到所有祖先；共有的即为共同祖先
     */
    /**
     * 4.2.22 最短先导路径
     * Solution:
     *      从v/w搜索反向图,找到最近的共同祖先
     */
    /**
     * 4.2.23 强连通分量
     * Solution:
     *      所在的连通分量：从一个顶点出发，深度优先搜索，依次加入队列，没有则
     *           出队，找到自身则停止返回
     *      所有的连通分量：按顺序对顶点进行寻找（需要标记顶点剩余的出度与入读，入度为0不可作为邻接点，入度为0不可访问）
     */
    /**
     * 4.2.24 有向无环图中的汉密尔顿路径
     * Solution:
     *      计算给定图的拓扑排序并顺序检查拓扑排序中每一对相邻顶点之间是否存在一条边
     *      （此方法的到的图就是一条汉密尔顿路径）
     */
    /**
     * 4.2.25 唯一的拓扑排序
     * Solution:
     *      当且仅当拓扑排序中每一对相邻顶点之间都存在一条有向边
     */
    /**
     * 4.2.26 2-可满足性
     * Solution:
     *      没读懂
     */
    /**
     * 4.2.27 有向无环图的枚举
     * Solution:
     *      V个顶点可以有的边数为(v-1) + (v-2) + ... + 1 = (v-1)v/2, 记为N
     *      A(2,N) * (A(2,N-2)+A(1,2)*A(1,N-2)) * (A(2,N-4)+A(2,N-3)+A(1,3)*A(1,N-3))...
     */



}
